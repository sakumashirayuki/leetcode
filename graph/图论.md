# 图论算法JavaScript实现
## 邻接矩阵建立图
输入为有向图，其中：<p>
--values： 所有顶点的值<p>
--edges： 数组存储所有的边。边的方向为从第一个顶点到第二个顶点

Vex类：<p>
--data: 存储顶点值<p>
--edge：准确的说应该是存储相邻顶点的数组<p>
--in：记录入度<p>
```javascript
class Vex{
    constructor(value){
        this.data = value;
        this.edge = [];// use adjacent matrix, contain the index
        this.in = 0; // the indegree of the vex
    }
}

class Graph{
    constructor(v, vr){ // v is the value array, vr is the edge array
        const vexs = new Array(v.length).fill(null).map((_,id)=>new Vex(v[id])); // v and vexs have corresponding index
        for(const edge of vr){
            const v1 = v.indexOf(edge[0]); // from vertex1 to vertex2
            const v2 = v.indexOf(edge[1]); // v1 is the index of vertex1, v2 is the index of vertex2
            vexs[v1].edge.push(v2);
            vexs[v2].in++;
        }
        this.adjmatrix = vexs;
    }
}
const values = [1,2,3,4,5,6,7];
const edges = [[1,2],[1,3],[1,4],[2,4],[2,5],[3,6],[4,3],[4,6],[4,7],[5,4],[5,7],[7,6]];
const myGraph = new Graph(values, edges);
for(const vNode of myGraph.adjmatrix){
    console.log("current Node", vNode.data);
    console.log("adjacent vertex");
    for(const e of vNode.edge){
        console.log(e);
    }
}
```
## 拓扑排序
拓扑排序（topological sort）是对有向无圈图的顶点的一种排序，使得如果存在一条从$v_i$到$v_j$的路径，那么在排序中，$v_j$就在$v_i$的后面出现。
### 简单方法
一个简单的拓扑排序算法是先找出任意一个没有入边（imcoming edge）的顶点，然后将该顶点的值push入排序数组，再将它和它的边一起从图中删除。
```javascript
const findNewVertexOfIndegreeZero = (G)=>{
    let zeroInVertex = null;
    const vexNumber = G.adjmatrix.length;
    for(let i = 0; i < vexNumber; i++){
        if(G.adjmatrix[i]&&G.adjmatrix[i].in===0){ // some vertex has been deleted
            zeroInVertex = JSON.parse(JSON.stringify(G.adjmatrix[i])); // copy this vertex instance
            G.adjmatrix[i] = null; // delete this vertex
            break;
        }
    }
    return zeroInVertex;
}

const topsort = (G)=>{
    const n = G.adjmatrix.length; // number of vertex
    const sortArray = []; 
    for(let i = 0; i < n; i++){
        const v = findNewVertexOfIndegreeZero(G); // return the vertex
        if(v==null)
            throw Error("there's a cycle in the graph!");   
        sortArray.push(v.data);
        // delete this vertex
        for(const adjacentVInd of v.edge){ // adjacentV is the index in adjmatrix
            if(G.adjmatrix[adjacentVInd]){// some have been deleted to null
                G.adjmatrix[adjacentVInd].in--;
            } 
        }
    }
    return sortArray;
}

const values = [1,2,3,4,5,6,7];
const edges = [[1,2],[1,3],[1,4],[2,4],[2,5],[3,6],[4,3],[4,6],[4,7],[5,4],[5,7],[7,6]];
const myGraph = new Graph(values, edges);
console.log(topsort(myGraph));
```
这个方法的缺点是对顶点的重复扫描，时间复杂度为O(V^2)
### 改进方法

