## 题目描述
有 n 根长度互不相同的木棍，长度为从 1 到 n 的整数。请你将这些木棍排成一排，并满足从左侧 可以看到 恰好 k 根木棍。从左侧 可以看到 木棍的前提是这个木棍的 左侧 不存在比它 更长的 木棍。

例如，如果木棍排列为 [1,3,2,5,4] ，那么从左侧可以看到的就是长度分别为 1、3 、5 的木棍。
给你 n 和 k ，返回符合题目要求的排列 数目 。由于答案可能很大，请返回对 109 + 7 取余 的结果。
## 解法
这是一道动态规划题。假设用dp[i][j]表示长度为1,2,...,i的木棍且可以看到j根木棍的方案数，则我们可以分两种情况讨论：
1. 最后一根木棍可以被看到
那么这最后一根木棍的长度一定为i，则dp[i][j] = dp[i-1][j-1].(因为最后一根被看到的木棍在前面木棍的排列确定的情况下，只有这一种放置方案)
2. 最后一根木棍不能被看到
那么这最后一根木棍的长度为[1,i-1]中的某一值，假设为x，则前面木棍的长度为1,...,x-1,x+1,...,i（即只是缺少x）。前面木棍的排列数量等同于，长度为1,...,i-1的木棍的排列数量，所以dp[i][j] = dp[i-1][j] * (i-1).因为x的取值有(i-1)种取法。

综合上述两种情况，最终的状态转移方程为：dp[i][j]=dp[i-1][j-1]+dp[i-1][j]*(i-1)
由于我们每次只在i和i-1之间转移，用两个一维数组存储状态即可。
## 源码
```javascript
var rearrangeSticks = function(n, k) {
    let f = new Array(k + 1).fill(0n);
    f[0] = 1n; // dp[0][0] = 1
    for(let i = 1; i <= n; i++){
        const g = new Array(k + 1).fill(0n);
        for(let j = 1; j <= k; j++){
            g[j] = f[j - 1] + f[j] * BigInt(i - 1);
        }
        f = g;
    }
    return f[k] % BigInt(1e9 + 7);
};
```