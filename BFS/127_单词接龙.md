# 题目描述
字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列：
* 序列中第一个单词是 beginWord 。
* 序列中最后一个单词是 endWord 。
* 每次转换只能改变一个字母。
* 转换过程中的中间单词必须是字典 wordList 中的单词。
* endWord也应在字典wordList中。
<p>给你两个单词 beginWord 和 endWord 和一个字典 wordList ，找到从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0。<p>

# 方法简介
广度优先搜索转换单词，直到转换单词为endWord
# 所需数据结构
* 队列，存放[word, level], level表示当前单词序列长度。
* Set 存储词典wordList中所有的单词，并在单词被放入队列后，从Set中删去该单词，避免形成有重复单词的序列。
# 知识点
## ```Set```数据结构
methods有：<p>
```Set.prototype.add(value)```<p>
```Set.prototype.clear()``` remove all elements from the Set object<p>
```Set.prototype.delete(value)```<p>
```Set.prototype.has(value)```<p>
## 由UTF-16 code得到string
```String.fromCharCode(UTF)```
# 源码
```javascript
var ladderLength = function(beginWord, endWord, wordList) {
    const wordSet = new Set(wordList);
    const queue = [[beginWord, 1]]; // [word, level]
    while(queue.length){
        const [currentWord, level] = queue.shift();
        for(let i=0;i<currentWord.length;i++){ // for each char of currentWord
            for(let j=97;j<=122;j++){ // loop through all lowercase letter
                const newWord = currentWord.slice(0,i) + String.fromCharCode(j) + currentWord.slice(i+1, currentWord.length);
                if(newWord==endWord && wordSet.has(newWord))
                    return level+1;
                else if(wordSet.has(newWord)){
                    queue.push([newWord, level+1]);
                    wordSet.delete(newWord);// prevent loop route
                }
            }
        } 
    }
    return 0;
};
```